// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Dnlbb/chat-server/internal/service/servinterfaces.ChatService -o chat_service_minimock.go -n ChatServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Dnlbb/chat-server/internal/models"
	"github.com/gojuno/minimock/v3"
)

// ChatServiceMock implements mm_servinterfaces.ChatService
type ChatServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, IDs models.IDs) (ip1 *int64, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, IDs models.IDs)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mChatServiceMockCreate

	funcDelete          func(ctx context.Context, chatID models.ChatID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, chatID models.ChatID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mChatServiceMockDelete

	funcGetIDs          func(ctx context.Context, chatID models.Usernames) (i1 models.IDs, err error)
	funcGetIDsOrigin    string
	inspectFuncGetIDs   func(ctx context.Context, chatID models.Usernames)
	afterGetIDsCounter  uint64
	beforeGetIDsCounter uint64
	GetIDsMock          mChatServiceMockGetIDs

	funcSendMessage          func(ctx context.Context, message models.Message) (err error)
	funcSendMessageOrigin    string
	inspectFuncSendMessage   func(ctx context.Context, message models.Message)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mChatServiceMockSendMessage
}

// NewChatServiceMock returns a mock for mm_servinterfaces.ChatService
func NewChatServiceMock(t minimock.Tester) *ChatServiceMock {
	m := &ChatServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mChatServiceMockCreate{mock: m}
	m.CreateMock.callArgs = []*ChatServiceMockCreateParams{}

	m.DeleteMock = mChatServiceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ChatServiceMockDeleteParams{}

	m.GetIDsMock = mChatServiceMockGetIDs{mock: m}
	m.GetIDsMock.callArgs = []*ChatServiceMockGetIDsParams{}

	m.SendMessageMock = mChatServiceMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ChatServiceMockSendMessageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mChatServiceMockCreate struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockCreateExpectation
	expectations       []*ChatServiceMockCreateExpectation

	callArgs []*ChatServiceMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockCreateExpectation specifies expectation struct of the ChatService.Create
type ChatServiceMockCreateExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockCreateParams
	paramPtrs          *ChatServiceMockCreateParamPtrs
	expectationOrigins ChatServiceMockCreateExpectationOrigins
	results            *ChatServiceMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockCreateParams contains parameters of the ChatService.Create
type ChatServiceMockCreateParams struct {
	ctx context.Context
	IDs models.IDs
}

// ChatServiceMockCreateParamPtrs contains pointers to parameters of the ChatService.Create
type ChatServiceMockCreateParamPtrs struct {
	ctx *context.Context
	IDs *models.IDs
}

// ChatServiceMockCreateResults contains results of the ChatService.Create
type ChatServiceMockCreateResults struct {
	ip1 *int64
	err error
}

// ChatServiceMockCreateOrigins contains origins of expectations of the ChatService.Create
type ChatServiceMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originIDs string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mChatServiceMockCreate) Optional() *mChatServiceMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for ChatService.Create
func (mmCreate *mChatServiceMockCreate) Expect(ctx context.Context, IDs models.IDs) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &ChatServiceMockCreateParams{ctx, IDs}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectCtxParam1(ctx context.Context) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectIDsParam2 sets up expected param IDs for ChatService.Create
func (mmCreate *mChatServiceMockCreate) ExpectIDsParam2(IDs models.IDs) *mChatServiceMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &ChatServiceMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.IDs = &IDs
	mmCreate.defaultExpectation.expectationOrigins.originIDs = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Create
func (mmCreate *mChatServiceMockCreate) Inspect(f func(ctx context.Context, IDs models.IDs)) *mChatServiceMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by ChatService.Create
func (mmCreate *mChatServiceMockCreate) Return(ip1 *int64, err error) *ChatServiceMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &ChatServiceMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &ChatServiceMockCreateResults{ip1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the ChatService.Create method
func (mmCreate *mChatServiceMockCreate) Set(f func(ctx context.Context, IDs models.IDs) (ip1 *int64, err error)) *ChatServiceMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the ChatService.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the ChatService.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the ChatService.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mChatServiceMockCreate) When(ctx context.Context, IDs models.IDs) *ChatServiceMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("ChatServiceMock.Create mock is already set by Set")
	}

	expectation := &ChatServiceMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &ChatServiceMockCreateParams{ctx, IDs},
		expectationOrigins: ChatServiceMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Create return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockCreateExpectation) Then(ip1 *int64, err error) *ChatServiceMock {
	e.results = &ChatServiceMockCreateResults{ip1, err}
	return e.mock
}

// Times sets number of times ChatService.Create should be invoked
func (mmCreate *mChatServiceMockCreate) Times(n uint64) *mChatServiceMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of ChatServiceMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mChatServiceMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_servinterfaces.ChatService
func (mmCreate *ChatServiceMock) Create(ctx context.Context, IDs models.IDs) (ip1 *int64, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, IDs)
	}

	mm_params := ChatServiceMockCreateParams{ctx, IDs}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockCreateParams{ctx, IDs}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.IDs != nil && !minimock.Equal(*mm_want_ptrs.IDs, mm_got.IDs) {
				mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameter IDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originIDs, *mm_want_ptrs.IDs, mm_got.IDs, minimock.Diff(*mm_want_ptrs.IDs, mm_got.IDs))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("ChatServiceMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the ChatServiceMock.Create")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, IDs)
	}
	mmCreate.t.Fatalf("Unexpected call to ChatServiceMock.Create. %v %v", ctx, IDs)
	return
}

// CreateAfterCounter returns a count of finished ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of ChatServiceMock.Create invocations
func (mmCreate *ChatServiceMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mChatServiceMockCreate) Calls() []*ChatServiceMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*ChatServiceMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mChatServiceMockDelete struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockDeleteExpectation
	expectations       []*ChatServiceMockDeleteExpectation

	callArgs []*ChatServiceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockDeleteExpectation specifies expectation struct of the ChatService.Delete
type ChatServiceMockDeleteExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockDeleteParams
	paramPtrs          *ChatServiceMockDeleteParamPtrs
	expectationOrigins ChatServiceMockDeleteExpectationOrigins
	results            *ChatServiceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockDeleteParams contains parameters of the ChatService.Delete
type ChatServiceMockDeleteParams struct {
	ctx    context.Context
	chatID models.ChatID
}

// ChatServiceMockDeleteParamPtrs contains pointers to parameters of the ChatService.Delete
type ChatServiceMockDeleteParamPtrs struct {
	ctx    *context.Context
	chatID *models.ChatID
}

// ChatServiceMockDeleteResults contains results of the ChatService.Delete
type ChatServiceMockDeleteResults struct {
	err error
}

// ChatServiceMockDeleteOrigins contains origins of expectations of the ChatService.Delete
type ChatServiceMockDeleteExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mChatServiceMockDelete) Optional() *mChatServiceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Expect(ctx context.Context, chatID models.ChatID) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &ChatServiceMockDeleteParams{ctx, chatID}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) ExpectCtxParam1(ctx context.Context) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.Delete
func (mmDelete *mChatServiceMockDelete) ExpectChatIDParam2(chatID models.ChatID) *mChatServiceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &ChatServiceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.chatID = &chatID
	mmDelete.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Inspect(f func(ctx context.Context, chatID models.ChatID)) *mChatServiceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by ChatService.Delete
func (mmDelete *mChatServiceMockDelete) Return(err error) *ChatServiceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ChatServiceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ChatServiceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the ChatService.Delete method
func (mmDelete *mChatServiceMockDelete) Set(f func(ctx context.Context, chatID models.ChatID) (err error)) *ChatServiceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the ChatService.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the ChatService.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the ChatService.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mChatServiceMockDelete) When(ctx context.Context, chatID models.ChatID) *ChatServiceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ChatServiceMock.Delete mock is already set by Set")
	}

	expectation := &ChatServiceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &ChatServiceMockDeleteParams{ctx, chatID},
		expectationOrigins: ChatServiceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up ChatService.Delete return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockDeleteExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times ChatService.Delete should be invoked
func (mmDelete *mChatServiceMockDelete) Times(n uint64) *mChatServiceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of ChatServiceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mChatServiceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_servinterfaces.ChatService
func (mmDelete *ChatServiceMock) Delete(ctx context.Context, chatID models.ChatID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, chatID)
	}

	mm_params := ChatServiceMockDeleteParams{ctx, chatID}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockDeleteParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ChatServiceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ChatServiceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, chatID)
	}
	mmDelete.t.Fatalf("Unexpected call to ChatServiceMock.Delete. %v %v", ctx, chatID)
	return
}

// DeleteAfterCounter returns a count of finished ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ChatServiceMock.Delete invocations
func (mmDelete *ChatServiceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mChatServiceMockDelete) Calls() []*ChatServiceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ChatServiceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mChatServiceMockGetIDs struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockGetIDsExpectation
	expectations       []*ChatServiceMockGetIDsExpectation

	callArgs []*ChatServiceMockGetIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockGetIDsExpectation specifies expectation struct of the ChatService.GetIDs
type ChatServiceMockGetIDsExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockGetIDsParams
	paramPtrs          *ChatServiceMockGetIDsParamPtrs
	expectationOrigins ChatServiceMockGetIDsExpectationOrigins
	results            *ChatServiceMockGetIDsResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockGetIDsParams contains parameters of the ChatService.GetIDs
type ChatServiceMockGetIDsParams struct {
	ctx    context.Context
	chatID models.Usernames
}

// ChatServiceMockGetIDsParamPtrs contains pointers to parameters of the ChatService.GetIDs
type ChatServiceMockGetIDsParamPtrs struct {
	ctx    *context.Context
	chatID *models.Usernames
}

// ChatServiceMockGetIDsResults contains results of the ChatService.GetIDs
type ChatServiceMockGetIDsResults struct {
	i1  models.IDs
	err error
}

// ChatServiceMockGetIDsOrigins contains origins of expectations of the ChatService.GetIDs
type ChatServiceMockGetIDsExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetIDs *mChatServiceMockGetIDs) Optional() *mChatServiceMockGetIDs {
	mmGetIDs.optional = true
	return mmGetIDs
}

// Expect sets up expected params for ChatService.GetIDs
func (mmGetIDs *mChatServiceMockGetIDs) Expect(ctx context.Context, chatID models.Usernames) *mChatServiceMockGetIDs {
	if mmGetIDs.mock.funcGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Set")
	}

	if mmGetIDs.defaultExpectation == nil {
		mmGetIDs.defaultExpectation = &ChatServiceMockGetIDsExpectation{}
	}

	if mmGetIDs.defaultExpectation.paramPtrs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by ExpectParams functions")
	}

	mmGetIDs.defaultExpectation.params = &ChatServiceMockGetIDsParams{ctx, chatID}
	mmGetIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetIDs.expectations {
		if minimock.Equal(e.params, mmGetIDs.defaultExpectation.params) {
			mmGetIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetIDs.defaultExpectation.params)
		}
	}

	return mmGetIDs
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.GetIDs
func (mmGetIDs *mChatServiceMockGetIDs) ExpectCtxParam1(ctx context.Context) *mChatServiceMockGetIDs {
	if mmGetIDs.mock.funcGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Set")
	}

	if mmGetIDs.defaultExpectation == nil {
		mmGetIDs.defaultExpectation = &ChatServiceMockGetIDsExpectation{}
	}

	if mmGetIDs.defaultExpectation.params != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Expect")
	}

	if mmGetIDs.defaultExpectation.paramPtrs == nil {
		mmGetIDs.defaultExpectation.paramPtrs = &ChatServiceMockGetIDsParamPtrs{}
	}
	mmGetIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetIDs
}

// ExpectChatIDParam2 sets up expected param chatID for ChatService.GetIDs
func (mmGetIDs *mChatServiceMockGetIDs) ExpectChatIDParam2(chatID models.Usernames) *mChatServiceMockGetIDs {
	if mmGetIDs.mock.funcGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Set")
	}

	if mmGetIDs.defaultExpectation == nil {
		mmGetIDs.defaultExpectation = &ChatServiceMockGetIDsExpectation{}
	}

	if mmGetIDs.defaultExpectation.params != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Expect")
	}

	if mmGetIDs.defaultExpectation.paramPtrs == nil {
		mmGetIDs.defaultExpectation.paramPtrs = &ChatServiceMockGetIDsParamPtrs{}
	}
	mmGetIDs.defaultExpectation.paramPtrs.chatID = &chatID
	mmGetIDs.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmGetIDs
}

// Inspect accepts an inspector function that has same arguments as the ChatService.GetIDs
func (mmGetIDs *mChatServiceMockGetIDs) Inspect(f func(ctx context.Context, chatID models.Usernames)) *mChatServiceMockGetIDs {
	if mmGetIDs.mock.inspectFuncGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.GetIDs")
	}

	mmGetIDs.mock.inspectFuncGetIDs = f

	return mmGetIDs
}

// Return sets up results that will be returned by ChatService.GetIDs
func (mmGetIDs *mChatServiceMockGetIDs) Return(i1 models.IDs, err error) *ChatServiceMock {
	if mmGetIDs.mock.funcGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Set")
	}

	if mmGetIDs.defaultExpectation == nil {
		mmGetIDs.defaultExpectation = &ChatServiceMockGetIDsExpectation{mock: mmGetIDs.mock}
	}
	mmGetIDs.defaultExpectation.results = &ChatServiceMockGetIDsResults{i1, err}
	mmGetIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetIDs.mock
}

// Set uses given function f to mock the ChatService.GetIDs method
func (mmGetIDs *mChatServiceMockGetIDs) Set(f func(ctx context.Context, chatID models.Usernames) (i1 models.IDs, err error)) *ChatServiceMock {
	if mmGetIDs.defaultExpectation != nil {
		mmGetIDs.mock.t.Fatalf("Default expectation is already set for the ChatService.GetIDs method")
	}

	if len(mmGetIDs.expectations) > 0 {
		mmGetIDs.mock.t.Fatalf("Some expectations are already set for the ChatService.GetIDs method")
	}

	mmGetIDs.mock.funcGetIDs = f
	mmGetIDs.mock.funcGetIDsOrigin = minimock.CallerInfo(1)
	return mmGetIDs.mock
}

// When sets expectation for the ChatService.GetIDs which will trigger the result defined by the following
// Then helper
func (mmGetIDs *mChatServiceMockGetIDs) When(ctx context.Context, chatID models.Usernames) *ChatServiceMockGetIDsExpectation {
	if mmGetIDs.mock.funcGetIDs != nil {
		mmGetIDs.mock.t.Fatalf("ChatServiceMock.GetIDs mock is already set by Set")
	}

	expectation := &ChatServiceMockGetIDsExpectation{
		mock:               mmGetIDs.mock,
		params:             &ChatServiceMockGetIDsParams{ctx, chatID},
		expectationOrigins: ChatServiceMockGetIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetIDs.expectations = append(mmGetIDs.expectations, expectation)
	return expectation
}

// Then sets up ChatService.GetIDs return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockGetIDsExpectation) Then(i1 models.IDs, err error) *ChatServiceMock {
	e.results = &ChatServiceMockGetIDsResults{i1, err}
	return e.mock
}

// Times sets number of times ChatService.GetIDs should be invoked
func (mmGetIDs *mChatServiceMockGetIDs) Times(n uint64) *mChatServiceMockGetIDs {
	if n == 0 {
		mmGetIDs.mock.t.Fatalf("Times of ChatServiceMock.GetIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetIDs.expectedInvocations, n)
	mmGetIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetIDs
}

func (mmGetIDs *mChatServiceMockGetIDs) invocationsDone() bool {
	if len(mmGetIDs.expectations) == 0 && mmGetIDs.defaultExpectation == nil && mmGetIDs.mock.funcGetIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetIDs.mock.afterGetIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetIDs implements mm_servinterfaces.ChatService
func (mmGetIDs *ChatServiceMock) GetIDs(ctx context.Context, chatID models.Usernames) (i1 models.IDs, err error) {
	mm_atomic.AddUint64(&mmGetIDs.beforeGetIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetIDs.afterGetIDsCounter, 1)

	mmGetIDs.t.Helper()

	if mmGetIDs.inspectFuncGetIDs != nil {
		mmGetIDs.inspectFuncGetIDs(ctx, chatID)
	}

	mm_params := ChatServiceMockGetIDsParams{ctx, chatID}

	// Record call args
	mmGetIDs.GetIDsMock.mutex.Lock()
	mmGetIDs.GetIDsMock.callArgs = append(mmGetIDs.GetIDsMock.callArgs, &mm_params)
	mmGetIDs.GetIDsMock.mutex.Unlock()

	for _, e := range mmGetIDs.GetIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmGetIDs.GetIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetIDs.GetIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetIDs.GetIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetIDs.GetIDsMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockGetIDsParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetIDs.t.Errorf("ChatServiceMock.GetIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetIDs.GetIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmGetIDs.t.Errorf("ChatServiceMock.GetIDs got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetIDs.GetIDsMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetIDs.t.Errorf("ChatServiceMock.GetIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetIDs.GetIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetIDs.GetIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetIDs.t.Fatal("No results are set for the ChatServiceMock.GetIDs")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmGetIDs.funcGetIDs != nil {
		return mmGetIDs.funcGetIDs(ctx, chatID)
	}
	mmGetIDs.t.Fatalf("Unexpected call to ChatServiceMock.GetIDs. %v %v", ctx, chatID)
	return
}

// GetIDsAfterCounter returns a count of finished ChatServiceMock.GetIDs invocations
func (mmGetIDs *ChatServiceMock) GetIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIDs.afterGetIDsCounter)
}

// GetIDsBeforeCounter returns a count of ChatServiceMock.GetIDs invocations
func (mmGetIDs *ChatServiceMock) GetIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetIDs.beforeGetIDsCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.GetIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetIDs *mChatServiceMockGetIDs) Calls() []*ChatServiceMockGetIDsParams {
	mmGetIDs.mutex.RLock()

	argCopy := make([]*ChatServiceMockGetIDsParams, len(mmGetIDs.callArgs))
	copy(argCopy, mmGetIDs.callArgs)

	mmGetIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetIDsDone returns true if the count of the GetIDs invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockGetIDsDone() bool {
	if m.GetIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetIDsMock.invocationsDone()
}

// MinimockGetIDsInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockGetIDsInspect() {
	for _, e := range m.GetIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.GetIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetIDsCounter := mm_atomic.LoadUint64(&m.afterGetIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetIDsMock.defaultExpectation != nil && afterGetIDsCounter < 1 {
		if m.GetIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.GetIDs at\n%s", m.GetIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.GetIDs at\n%s with params: %#v", m.GetIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetIDs != nil && afterGetIDsCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.GetIDs at\n%s", m.funcGetIDsOrigin)
	}

	if !m.GetIDsMock.invocationsDone() && afterGetIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.GetIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetIDsMock.expectedInvocations), m.GetIDsMock.expectedInvocationsOrigin, afterGetIDsCounter)
	}
}

type mChatServiceMockSendMessage struct {
	optional           bool
	mock               *ChatServiceMock
	defaultExpectation *ChatServiceMockSendMessageExpectation
	expectations       []*ChatServiceMockSendMessageExpectation

	callArgs []*ChatServiceMockSendMessageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ChatServiceMockSendMessageExpectation specifies expectation struct of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectation struct {
	mock               *ChatServiceMock
	params             *ChatServiceMockSendMessageParams
	paramPtrs          *ChatServiceMockSendMessageParamPtrs
	expectationOrigins ChatServiceMockSendMessageExpectationOrigins
	results            *ChatServiceMockSendMessageResults
	returnOrigin       string
	Counter            uint64
}

// ChatServiceMockSendMessageParams contains parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParams struct {
	ctx     context.Context
	message models.Message
}

// ChatServiceMockSendMessageParamPtrs contains pointers to parameters of the ChatService.SendMessage
type ChatServiceMockSendMessageParamPtrs struct {
	ctx     *context.Context
	message *models.Message
}

// ChatServiceMockSendMessageResults contains results of the ChatService.SendMessage
type ChatServiceMockSendMessageResults struct {
	err error
}

// ChatServiceMockSendMessageOrigins contains origins of expectations of the ChatService.SendMessage
type ChatServiceMockSendMessageExpectationOrigins struct {
	origin        string
	originCtx     string
	originMessage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessage *mChatServiceMockSendMessage) Optional() *mChatServiceMockSendMessage {
	mmSendMessage.optional = true
	return mmSendMessage
}

// Expect sets up expected params for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Expect(ctx context.Context, message models.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.paramPtrs != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by ExpectParams functions")
	}

	mmSendMessage.defaultExpectation.params = &ChatServiceMockSendMessageParams{ctx, message}
	mmSendMessage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// ExpectCtxParam1 sets up expected param ctx for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectCtxParam1(ctx context.Context) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessage
}

// ExpectMessageParam2 sets up expected param message for ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) ExpectMessageParam2(message models.Message) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{}
	}

	if mmSendMessage.defaultExpectation.params != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Expect")
	}

	if mmSendMessage.defaultExpectation.paramPtrs == nil {
		mmSendMessage.defaultExpectation.paramPtrs = &ChatServiceMockSendMessageParamPtrs{}
	}
	mmSendMessage.defaultExpectation.paramPtrs.message = &message
	mmSendMessage.defaultExpectation.expectationOrigins.originMessage = minimock.CallerInfo(1)

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Inspect(f func(ctx context.Context, message models.Message)) *mChatServiceMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ChatServiceMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by ChatService.SendMessage
func (mmSendMessage *mChatServiceMockSendMessage) Return(err error) *ChatServiceMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ChatServiceMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ChatServiceMockSendMessageResults{err}
	mmSendMessage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// Set uses given function f to mock the ChatService.SendMessage method
func (mmSendMessage *mChatServiceMockSendMessage) Set(f func(ctx context.Context, message models.Message) (err error)) *ChatServiceMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the ChatService.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the ChatService.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	mmSendMessage.mock.funcSendMessageOrigin = minimock.CallerInfo(1)
	return mmSendMessage.mock
}

// When sets expectation for the ChatService.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mChatServiceMockSendMessage) When(ctx context.Context, message models.Message) *ChatServiceMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ChatServiceMock.SendMessage mock is already set by Set")
	}

	expectation := &ChatServiceMockSendMessageExpectation{
		mock:               mmSendMessage.mock,
		params:             &ChatServiceMockSendMessageParams{ctx, message},
		expectationOrigins: ChatServiceMockSendMessageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up ChatService.SendMessage return parameters for the expectation previously defined by the When method
func (e *ChatServiceMockSendMessageExpectation) Then(err error) *ChatServiceMock {
	e.results = &ChatServiceMockSendMessageResults{err}
	return e.mock
}

// Times sets number of times ChatService.SendMessage should be invoked
func (mmSendMessage *mChatServiceMockSendMessage) Times(n uint64) *mChatServiceMockSendMessage {
	if n == 0 {
		mmSendMessage.mock.t.Fatalf("Times of ChatServiceMock.SendMessage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessage.expectedInvocations, n)
	mmSendMessage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessage
}

func (mmSendMessage *mChatServiceMockSendMessage) invocationsDone() bool {
	if len(mmSendMessage.expectations) == 0 && mmSendMessage.defaultExpectation == nil && mmSendMessage.mock.funcSendMessage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessage.mock.afterSendMessageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessage implements mm_servinterfaces.ChatService
func (mmSendMessage *ChatServiceMock) SendMessage(ctx context.Context, message models.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	mmSendMessage.t.Helper()

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(ctx, message)
	}

	mm_params := ChatServiceMockSendMessageParams{ctx, message}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, &mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessage.SendMessageMock.defaultExpectation.paramPtrs

		mm_got := ChatServiceMockSendMessageParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameter message, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.originMessage, *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ChatServiceMock.SendMessage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessage.SendMessageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ChatServiceMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(ctx, message)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ChatServiceMock.SendMessage. %v %v", ctx, message)
	return
}

// SendMessageAfterCounter returns a count of finished ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ChatServiceMock.SendMessage invocations
func (mmSendMessage *ChatServiceMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ChatServiceMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mChatServiceMockSendMessage) Calls() []*ChatServiceMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ChatServiceMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ChatServiceMock) MinimockSendMessageDone() bool {
	if m.SendMessageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageMock.invocationsDone()
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ChatServiceMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageCounter := mm_atomic.LoadUint64(&m.afterSendMessageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && afterSendMessageCounter < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.SendMessageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s with params: %#v", m.SendMessageMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && afterSendMessageCounter < 1 {
		m.t.Errorf("Expected call to ChatServiceMock.SendMessage at\n%s", m.funcSendMessageOrigin)
	}

	if !m.SendMessageMock.invocationsDone() && afterSendMessageCounter > 0 {
		m.t.Errorf("Expected %d calls to ChatServiceMock.SendMessage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageMock.expectedInvocations), m.SendMessageMock.expectedInvocationsOrigin, afterSendMessageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ChatServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockDeleteInspect()

			m.MinimockGetIDsInspect()

			m.MinimockSendMessageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ChatServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ChatServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockGetIDsDone() &&
		m.MinimockSendMessageDone()
}
