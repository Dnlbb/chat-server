// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Dnlbb/chat-server/internal/repository/repointerface.StorageInterface -o storage_interface_minimock.go -n StorageInterfaceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Dnlbb/chat-server/internal/models"
	"github.com/gojuno/minimock/v3"
)

// StorageInterfaceMock implements mm_repointerface.StorageInterface
type StorageInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateChat          func(ctx context.Context, id models.IDs) (ip1 *int64, err error)
	funcCreateChatOrigin    string
	inspectFuncCreateChat   func(ctx context.Context, id models.IDs)
	afterCreateChatCounter  uint64
	beforeCreateChatCounter uint64
	CreateChatMock          mStorageInterfaceMockCreateChat

	funcDeleteChat          func(ctx context.Context, chatID models.ChatID) (err error)
	funcDeleteChatOrigin    string
	inspectFuncDeleteChat   func(ctx context.Context, chatID models.ChatID)
	afterDeleteChatCounter  uint64
	beforeDeleteChatCounter uint64
	DeleteChatMock          mStorageInterfaceMockDeleteChat

	funcLog          func(ctx context.Context, key models.LogKey) (err error)
	funcLogOrigin    string
	inspectFuncLog   func(ctx context.Context, key models.LogKey)
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mStorageInterfaceMockLog

	funcSendMessageChat          func(ctx context.Context, message models.Message) (err error)
	funcSendMessageChatOrigin    string
	inspectFuncSendMessageChat   func(ctx context.Context, message models.Message)
	afterSendMessageChatCounter  uint64
	beforeSendMessageChatCounter uint64
	SendMessageChatMock          mStorageInterfaceMockSendMessageChat
}

// NewStorageInterfaceMock returns a mock for mm_repointerface.StorageInterface
func NewStorageInterfaceMock(t minimock.Tester) *StorageInterfaceMock {
	m := &StorageInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateChatMock = mStorageInterfaceMockCreateChat{mock: m}
	m.CreateChatMock.callArgs = []*StorageInterfaceMockCreateChatParams{}

	m.DeleteChatMock = mStorageInterfaceMockDeleteChat{mock: m}
	m.DeleteChatMock.callArgs = []*StorageInterfaceMockDeleteChatParams{}

	m.LogMock = mStorageInterfaceMockLog{mock: m}
	m.LogMock.callArgs = []*StorageInterfaceMockLogParams{}

	m.SendMessageChatMock = mStorageInterfaceMockSendMessageChat{mock: m}
	m.SendMessageChatMock.callArgs = []*StorageInterfaceMockSendMessageChatParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageInterfaceMockCreateChat struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockCreateChatExpectation
	expectations       []*StorageInterfaceMockCreateChatExpectation

	callArgs []*StorageInterfaceMockCreateChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockCreateChatExpectation specifies expectation struct of the StorageInterface.CreateChat
type StorageInterfaceMockCreateChatExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockCreateChatParams
	paramPtrs          *StorageInterfaceMockCreateChatParamPtrs
	expectationOrigins StorageInterfaceMockCreateChatExpectationOrigins
	results            *StorageInterfaceMockCreateChatResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockCreateChatParams contains parameters of the StorageInterface.CreateChat
type StorageInterfaceMockCreateChatParams struct {
	ctx context.Context
	id  models.IDs
}

// StorageInterfaceMockCreateChatParamPtrs contains pointers to parameters of the StorageInterface.CreateChat
type StorageInterfaceMockCreateChatParamPtrs struct {
	ctx *context.Context
	id  *models.IDs
}

// StorageInterfaceMockCreateChatResults contains results of the StorageInterface.CreateChat
type StorageInterfaceMockCreateChatResults struct {
	ip1 *int64
	err error
}

// StorageInterfaceMockCreateChatOrigins contains origins of expectations of the StorageInterface.CreateChat
type StorageInterfaceMockCreateChatExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateChat *mStorageInterfaceMockCreateChat) Optional() *mStorageInterfaceMockCreateChat {
	mmCreateChat.optional = true
	return mmCreateChat
}

// Expect sets up expected params for StorageInterface.CreateChat
func (mmCreateChat *mStorageInterfaceMockCreateChat) Expect(ctx context.Context, id models.IDs) *mStorageInterfaceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &StorageInterfaceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.paramPtrs != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by ExpectParams functions")
	}

	mmCreateChat.defaultExpectation.params = &StorageInterfaceMockCreateChatParams{ctx, id}
	mmCreateChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateChat.expectations {
		if minimock.Equal(e.params, mmCreateChat.defaultExpectation.params) {
			mmCreateChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateChat.defaultExpectation.params)
		}
	}

	return mmCreateChat
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.CreateChat
func (mmCreateChat *mStorageInterfaceMockCreateChat) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &StorageInterfaceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &StorageInterfaceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateChat
}

// ExpectIdParam2 sets up expected param id for StorageInterface.CreateChat
func (mmCreateChat *mStorageInterfaceMockCreateChat) ExpectIdParam2(id models.IDs) *mStorageInterfaceMockCreateChat {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &StorageInterfaceMockCreateChatExpectation{}
	}

	if mmCreateChat.defaultExpectation.params != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Expect")
	}

	if mmCreateChat.defaultExpectation.paramPtrs == nil {
		mmCreateChat.defaultExpectation.paramPtrs = &StorageInterfaceMockCreateChatParamPtrs{}
	}
	mmCreateChat.defaultExpectation.paramPtrs.id = &id
	mmCreateChat.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmCreateChat
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.CreateChat
func (mmCreateChat *mStorageInterfaceMockCreateChat) Inspect(f func(ctx context.Context, id models.IDs)) *mStorageInterfaceMockCreateChat {
	if mmCreateChat.mock.inspectFuncCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.CreateChat")
	}

	mmCreateChat.mock.inspectFuncCreateChat = f

	return mmCreateChat
}

// Return sets up results that will be returned by StorageInterface.CreateChat
func (mmCreateChat *mStorageInterfaceMockCreateChat) Return(ip1 *int64, err error) *StorageInterfaceMock {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Set")
	}

	if mmCreateChat.defaultExpectation == nil {
		mmCreateChat.defaultExpectation = &StorageInterfaceMockCreateChatExpectation{mock: mmCreateChat.mock}
	}
	mmCreateChat.defaultExpectation.results = &StorageInterfaceMockCreateChatResults{ip1, err}
	mmCreateChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// Set uses given function f to mock the StorageInterface.CreateChat method
func (mmCreateChat *mStorageInterfaceMockCreateChat) Set(f func(ctx context.Context, id models.IDs) (ip1 *int64, err error)) *StorageInterfaceMock {
	if mmCreateChat.defaultExpectation != nil {
		mmCreateChat.mock.t.Fatalf("Default expectation is already set for the StorageInterface.CreateChat method")
	}

	if len(mmCreateChat.expectations) > 0 {
		mmCreateChat.mock.t.Fatalf("Some expectations are already set for the StorageInterface.CreateChat method")
	}

	mmCreateChat.mock.funcCreateChat = f
	mmCreateChat.mock.funcCreateChatOrigin = minimock.CallerInfo(1)
	return mmCreateChat.mock
}

// When sets expectation for the StorageInterface.CreateChat which will trigger the result defined by the following
// Then helper
func (mmCreateChat *mStorageInterfaceMockCreateChat) When(ctx context.Context, id models.IDs) *StorageInterfaceMockCreateChatExpectation {
	if mmCreateChat.mock.funcCreateChat != nil {
		mmCreateChat.mock.t.Fatalf("StorageInterfaceMock.CreateChat mock is already set by Set")
	}

	expectation := &StorageInterfaceMockCreateChatExpectation{
		mock:               mmCreateChat.mock,
		params:             &StorageInterfaceMockCreateChatParams{ctx, id},
		expectationOrigins: StorageInterfaceMockCreateChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateChat.expectations = append(mmCreateChat.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.CreateChat return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockCreateChatExpectation) Then(ip1 *int64, err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockCreateChatResults{ip1, err}
	return e.mock
}

// Times sets number of times StorageInterface.CreateChat should be invoked
func (mmCreateChat *mStorageInterfaceMockCreateChat) Times(n uint64) *mStorageInterfaceMockCreateChat {
	if n == 0 {
		mmCreateChat.mock.t.Fatalf("Times of StorageInterfaceMock.CreateChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateChat.expectedInvocations, n)
	mmCreateChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateChat
}

func (mmCreateChat *mStorageInterfaceMockCreateChat) invocationsDone() bool {
	if len(mmCreateChat.expectations) == 0 && mmCreateChat.defaultExpectation == nil && mmCreateChat.mock.funcCreateChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateChat.mock.afterCreateChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateChat implements mm_repointerface.StorageInterface
func (mmCreateChat *StorageInterfaceMock) CreateChat(ctx context.Context, id models.IDs) (ip1 *int64, err error) {
	mm_atomic.AddUint64(&mmCreateChat.beforeCreateChatCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateChat.afterCreateChatCounter, 1)

	mmCreateChat.t.Helper()

	if mmCreateChat.inspectFuncCreateChat != nil {
		mmCreateChat.inspectFuncCreateChat(ctx, id)
	}

	mm_params := StorageInterfaceMockCreateChatParams{ctx, id}

	// Record call args
	mmCreateChat.CreateChatMock.mutex.Lock()
	mmCreateChat.CreateChatMock.callArgs = append(mmCreateChat.CreateChatMock.callArgs, &mm_params)
	mmCreateChat.CreateChatMock.mutex.Unlock()

	for _, e := range mmCreateChat.CreateChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ip1, e.results.err
		}
	}

	if mmCreateChat.CreateChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateChat.CreateChatMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateChat.CreateChatMock.defaultExpectation.params
		mm_want_ptrs := mmCreateChat.CreateChatMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockCreateChatParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateChat.t.Errorf("StorageInterfaceMock.CreateChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmCreateChat.t.Errorf("StorageInterfaceMock.CreateChat got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateChat.t.Errorf("StorageInterfaceMock.CreateChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateChat.CreateChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateChat.CreateChatMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateChat.t.Fatal("No results are set for the StorageInterfaceMock.CreateChat")
		}
		return (*mm_results).ip1, (*mm_results).err
	}
	if mmCreateChat.funcCreateChat != nil {
		return mmCreateChat.funcCreateChat(ctx, id)
	}
	mmCreateChat.t.Fatalf("Unexpected call to StorageInterfaceMock.CreateChat. %v %v", ctx, id)
	return
}

// CreateChatAfterCounter returns a count of finished StorageInterfaceMock.CreateChat invocations
func (mmCreateChat *StorageInterfaceMock) CreateChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.afterCreateChatCounter)
}

// CreateChatBeforeCounter returns a count of StorageInterfaceMock.CreateChat invocations
func (mmCreateChat *StorageInterfaceMock) CreateChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateChat.beforeCreateChatCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.CreateChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateChat *mStorageInterfaceMockCreateChat) Calls() []*StorageInterfaceMockCreateChatParams {
	mmCreateChat.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockCreateChatParams, len(mmCreateChat.callArgs))
	copy(argCopy, mmCreateChat.callArgs)

	mmCreateChat.mutex.RUnlock()

	return argCopy
}

// MinimockCreateChatDone returns true if the count of the CreateChat invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockCreateChatDone() bool {
	if m.CreateChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateChatMock.invocationsDone()
}

// MinimockCreateChatInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockCreateChatInspect() {
	for _, e := range m.CreateChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.CreateChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateChatCounter := mm_atomic.LoadUint64(&m.afterCreateChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateChatMock.defaultExpectation != nil && afterCreateChatCounter < 1 {
		if m.CreateChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.CreateChat at\n%s", m.CreateChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.CreateChat at\n%s with params: %#v", m.CreateChatMock.defaultExpectation.expectationOrigins.origin, *m.CreateChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateChat != nil && afterCreateChatCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.CreateChat at\n%s", m.funcCreateChatOrigin)
	}

	if !m.CreateChatMock.invocationsDone() && afterCreateChatCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.CreateChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateChatMock.expectedInvocations), m.CreateChatMock.expectedInvocationsOrigin, afterCreateChatCounter)
	}
}

type mStorageInterfaceMockDeleteChat struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockDeleteChatExpectation
	expectations       []*StorageInterfaceMockDeleteChatExpectation

	callArgs []*StorageInterfaceMockDeleteChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockDeleteChatExpectation specifies expectation struct of the StorageInterface.DeleteChat
type StorageInterfaceMockDeleteChatExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockDeleteChatParams
	paramPtrs          *StorageInterfaceMockDeleteChatParamPtrs
	expectationOrigins StorageInterfaceMockDeleteChatExpectationOrigins
	results            *StorageInterfaceMockDeleteChatResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockDeleteChatParams contains parameters of the StorageInterface.DeleteChat
type StorageInterfaceMockDeleteChatParams struct {
	ctx    context.Context
	chatID models.ChatID
}

// StorageInterfaceMockDeleteChatParamPtrs contains pointers to parameters of the StorageInterface.DeleteChat
type StorageInterfaceMockDeleteChatParamPtrs struct {
	ctx    *context.Context
	chatID *models.ChatID
}

// StorageInterfaceMockDeleteChatResults contains results of the StorageInterface.DeleteChat
type StorageInterfaceMockDeleteChatResults struct {
	err error
}

// StorageInterfaceMockDeleteChatOrigins contains origins of expectations of the StorageInterface.DeleteChat
type StorageInterfaceMockDeleteChatExpectationOrigins struct {
	origin       string
	originCtx    string
	originChatID string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Optional() *mStorageInterfaceMockDeleteChat {
	mmDeleteChat.optional = true
	return mmDeleteChat
}

// Expect sets up expected params for StorageInterface.DeleteChat
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Expect(ctx context.Context, chatID models.ChatID) *mStorageInterfaceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &StorageInterfaceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.paramPtrs != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by ExpectParams functions")
	}

	mmDeleteChat.defaultExpectation.params = &StorageInterfaceMockDeleteChatParams{ctx, chatID}
	mmDeleteChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteChat.expectations {
		if minimock.Equal(e.params, mmDeleteChat.defaultExpectation.params) {
			mmDeleteChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteChat.defaultExpectation.params)
		}
	}

	return mmDeleteChat
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.DeleteChat
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &StorageInterfaceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &StorageInterfaceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteChat
}

// ExpectChatIDParam2 sets up expected param chatID for StorageInterface.DeleteChat
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) ExpectChatIDParam2(chatID models.ChatID) *mStorageInterfaceMockDeleteChat {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &StorageInterfaceMockDeleteChatExpectation{}
	}

	if mmDeleteChat.defaultExpectation.params != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Expect")
	}

	if mmDeleteChat.defaultExpectation.paramPtrs == nil {
		mmDeleteChat.defaultExpectation.paramPtrs = &StorageInterfaceMockDeleteChatParamPtrs{}
	}
	mmDeleteChat.defaultExpectation.paramPtrs.chatID = &chatID
	mmDeleteChat.defaultExpectation.expectationOrigins.originChatID = minimock.CallerInfo(1)

	return mmDeleteChat
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.DeleteChat
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Inspect(f func(ctx context.Context, chatID models.ChatID)) *mStorageInterfaceMockDeleteChat {
	if mmDeleteChat.mock.inspectFuncDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.DeleteChat")
	}

	mmDeleteChat.mock.inspectFuncDeleteChat = f

	return mmDeleteChat
}

// Return sets up results that will be returned by StorageInterface.DeleteChat
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Return(err error) *StorageInterfaceMock {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Set")
	}

	if mmDeleteChat.defaultExpectation == nil {
		mmDeleteChat.defaultExpectation = &StorageInterfaceMockDeleteChatExpectation{mock: mmDeleteChat.mock}
	}
	mmDeleteChat.defaultExpectation.results = &StorageInterfaceMockDeleteChatResults{err}
	mmDeleteChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// Set uses given function f to mock the StorageInterface.DeleteChat method
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Set(f func(ctx context.Context, chatID models.ChatID) (err error)) *StorageInterfaceMock {
	if mmDeleteChat.defaultExpectation != nil {
		mmDeleteChat.mock.t.Fatalf("Default expectation is already set for the StorageInterface.DeleteChat method")
	}

	if len(mmDeleteChat.expectations) > 0 {
		mmDeleteChat.mock.t.Fatalf("Some expectations are already set for the StorageInterface.DeleteChat method")
	}

	mmDeleteChat.mock.funcDeleteChat = f
	mmDeleteChat.mock.funcDeleteChatOrigin = minimock.CallerInfo(1)
	return mmDeleteChat.mock
}

// When sets expectation for the StorageInterface.DeleteChat which will trigger the result defined by the following
// Then helper
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) When(ctx context.Context, chatID models.ChatID) *StorageInterfaceMockDeleteChatExpectation {
	if mmDeleteChat.mock.funcDeleteChat != nil {
		mmDeleteChat.mock.t.Fatalf("StorageInterfaceMock.DeleteChat mock is already set by Set")
	}

	expectation := &StorageInterfaceMockDeleteChatExpectation{
		mock:               mmDeleteChat.mock,
		params:             &StorageInterfaceMockDeleteChatParams{ctx, chatID},
		expectationOrigins: StorageInterfaceMockDeleteChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteChat.expectations = append(mmDeleteChat.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.DeleteChat return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockDeleteChatExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockDeleteChatResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.DeleteChat should be invoked
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Times(n uint64) *mStorageInterfaceMockDeleteChat {
	if n == 0 {
		mmDeleteChat.mock.t.Fatalf("Times of StorageInterfaceMock.DeleteChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteChat.expectedInvocations, n)
	mmDeleteChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteChat
}

func (mmDeleteChat *mStorageInterfaceMockDeleteChat) invocationsDone() bool {
	if len(mmDeleteChat.expectations) == 0 && mmDeleteChat.defaultExpectation == nil && mmDeleteChat.mock.funcDeleteChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteChat.mock.afterDeleteChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteChat implements mm_repointerface.StorageInterface
func (mmDeleteChat *StorageInterfaceMock) DeleteChat(ctx context.Context, chatID models.ChatID) (err error) {
	mm_atomic.AddUint64(&mmDeleteChat.beforeDeleteChatCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteChat.afterDeleteChatCounter, 1)

	mmDeleteChat.t.Helper()

	if mmDeleteChat.inspectFuncDeleteChat != nil {
		mmDeleteChat.inspectFuncDeleteChat(ctx, chatID)
	}

	mm_params := StorageInterfaceMockDeleteChatParams{ctx, chatID}

	// Record call args
	mmDeleteChat.DeleteChatMock.mutex.Lock()
	mmDeleteChat.DeleteChatMock.callArgs = append(mmDeleteChat.DeleteChatMock.callArgs, &mm_params)
	mmDeleteChat.DeleteChatMock.mutex.Unlock()

	for _, e := range mmDeleteChat.DeleteChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteChat.DeleteChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteChat.DeleteChatMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteChat.DeleteChatMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteChat.DeleteChatMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockDeleteChatParams{ctx, chatID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteChat.t.Errorf("StorageInterfaceMock.DeleteChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.chatID != nil && !minimock.Equal(*mm_want_ptrs.chatID, mm_got.chatID) {
				mmDeleteChat.t.Errorf("StorageInterfaceMock.DeleteChat got unexpected parameter chatID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.originChatID, *mm_want_ptrs.chatID, mm_got.chatID, minimock.Diff(*mm_want_ptrs.chatID, mm_got.chatID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteChat.t.Errorf("StorageInterfaceMock.DeleteChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteChat.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteChat.DeleteChatMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteChat.t.Fatal("No results are set for the StorageInterfaceMock.DeleteChat")
		}
		return (*mm_results).err
	}
	if mmDeleteChat.funcDeleteChat != nil {
		return mmDeleteChat.funcDeleteChat(ctx, chatID)
	}
	mmDeleteChat.t.Fatalf("Unexpected call to StorageInterfaceMock.DeleteChat. %v %v", ctx, chatID)
	return
}

// DeleteChatAfterCounter returns a count of finished StorageInterfaceMock.DeleteChat invocations
func (mmDeleteChat *StorageInterfaceMock) DeleteChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.afterDeleteChatCounter)
}

// DeleteChatBeforeCounter returns a count of StorageInterfaceMock.DeleteChat invocations
func (mmDeleteChat *StorageInterfaceMock) DeleteChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteChat.beforeDeleteChatCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.DeleteChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteChat *mStorageInterfaceMockDeleteChat) Calls() []*StorageInterfaceMockDeleteChatParams {
	mmDeleteChat.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockDeleteChatParams, len(mmDeleteChat.callArgs))
	copy(argCopy, mmDeleteChat.callArgs)

	mmDeleteChat.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteChatDone returns true if the count of the DeleteChat invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockDeleteChatDone() bool {
	if m.DeleteChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteChatMock.invocationsDone()
}

// MinimockDeleteChatInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockDeleteChatInspect() {
	for _, e := range m.DeleteChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.DeleteChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteChatCounter := mm_atomic.LoadUint64(&m.afterDeleteChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteChatMock.defaultExpectation != nil && afterDeleteChatCounter < 1 {
		if m.DeleteChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.DeleteChat at\n%s", m.DeleteChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.DeleteChat at\n%s with params: %#v", m.DeleteChatMock.defaultExpectation.expectationOrigins.origin, *m.DeleteChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteChat != nil && afterDeleteChatCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.DeleteChat at\n%s", m.funcDeleteChatOrigin)
	}

	if !m.DeleteChatMock.invocationsDone() && afterDeleteChatCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.DeleteChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteChatMock.expectedInvocations), m.DeleteChatMock.expectedInvocationsOrigin, afterDeleteChatCounter)
	}
}

type mStorageInterfaceMockLog struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockLogExpectation
	expectations       []*StorageInterfaceMockLogExpectation

	callArgs []*StorageInterfaceMockLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockLogExpectation specifies expectation struct of the StorageInterface.Log
type StorageInterfaceMockLogExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockLogParams
	paramPtrs          *StorageInterfaceMockLogParamPtrs
	expectationOrigins StorageInterfaceMockLogExpectationOrigins
	results            *StorageInterfaceMockLogResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockLogParams contains parameters of the StorageInterface.Log
type StorageInterfaceMockLogParams struct {
	ctx context.Context
	key models.LogKey
}

// StorageInterfaceMockLogParamPtrs contains pointers to parameters of the StorageInterface.Log
type StorageInterfaceMockLogParamPtrs struct {
	ctx *context.Context
	key *models.LogKey
}

// StorageInterfaceMockLogResults contains results of the StorageInterface.Log
type StorageInterfaceMockLogResults struct {
	err error
}

// StorageInterfaceMockLogOrigins contains origins of expectations of the StorageInterface.Log
type StorageInterfaceMockLogExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mStorageInterfaceMockLog) Optional() *mStorageInterfaceMockLog {
	mmLog.optional = true
	return mmLog
}

// Expect sets up expected params for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Expect(ctx context.Context, key models.LogKey) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.paramPtrs != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by ExpectParams functions")
	}

	mmLog.defaultExpectation.params = &StorageInterfaceMockLogParams{ctx, key}
	mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &StorageInterfaceMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLog
}

// ExpectKeyParam2 sets up expected param key for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) ExpectKeyParam2(key models.LogKey) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &StorageInterfaceMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.key = &key
	mmLog.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Inspect(f func(ctx context.Context, key models.LogKey)) *mStorageInterfaceMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Return(err error) *StorageInterfaceMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &StorageInterfaceMockLogResults{err}
	mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// Set uses given function f to mock the StorageInterface.Log method
func (mmLog *mStorageInterfaceMockLog) Set(f func(ctx context.Context, key models.LogKey) (err error)) *StorageInterfaceMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the StorageInterface.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the StorageInterface.Log method")
	}

	mmLog.mock.funcLog = f
	mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// When sets expectation for the StorageInterface.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mStorageInterfaceMockLog) When(ctx context.Context, key models.LogKey) *StorageInterfaceMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	expectation := &StorageInterfaceMockLogExpectation{
		mock:               mmLog.mock,
		params:             &StorageInterfaceMockLogParams{ctx, key},
		expectationOrigins: StorageInterfaceMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.Log return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockLogExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockLogResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.Log should be invoked
func (mmLog *mStorageInterfaceMockLog) Times(n uint64) *mStorageInterfaceMockLog {
	if n == 0 {
		mmLog.mock.t.Fatalf("Times of StorageInterfaceMock.Log mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLog.expectedInvocations, n)
	mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLog
}

func (mmLog *mStorageInterfaceMockLog) invocationsDone() bool {
	if len(mmLog.expectations) == 0 && mmLog.defaultExpectation == nil && mmLog.mock.funcLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLog.mock.afterLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Log implements mm_repointerface.StorageInterface
func (mmLog *StorageInterfaceMock) Log(ctx context.Context, key models.LogKey) (err error) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	mmLog.t.Helper()

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(ctx, key)
	}

	mm_params := StorageInterfaceMockLogParams{ctx, key}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockLogParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the StorageInterfaceMock.Log")
		}
		return (*mm_results).err
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog(ctx, key)
	}
	mmLog.t.Fatalf("Unexpected call to StorageInterfaceMock.Log. %v %v", ctx, key)
	return
}

// LogAfterCounter returns a count of finished StorageInterfaceMock.Log invocations
func (mmLog *StorageInterfaceMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of StorageInterfaceMock.Log invocations
func (mmLog *StorageInterfaceMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mStorageInterfaceMockLog) Calls() []*StorageInterfaceMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockLogDone() bool {
	if m.LogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogMock.invocationsDone()
}

// MinimockLogInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogCounter := mm_atomic.LoadUint64(&m.afterLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && afterLogCounter < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && afterLogCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s", m.funcLogOrigin)
	}

	if !m.LogMock.invocationsDone() && afterLogCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.Log at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
	}
}

type mStorageInterfaceMockSendMessageChat struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockSendMessageChatExpectation
	expectations       []*StorageInterfaceMockSendMessageChatExpectation

	callArgs []*StorageInterfaceMockSendMessageChatParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockSendMessageChatExpectation specifies expectation struct of the StorageInterface.SendMessageChat
type StorageInterfaceMockSendMessageChatExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockSendMessageChatParams
	paramPtrs          *StorageInterfaceMockSendMessageChatParamPtrs
	expectationOrigins StorageInterfaceMockSendMessageChatExpectationOrigins
	results            *StorageInterfaceMockSendMessageChatResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockSendMessageChatParams contains parameters of the StorageInterface.SendMessageChat
type StorageInterfaceMockSendMessageChatParams struct {
	ctx     context.Context
	message models.Message
}

// StorageInterfaceMockSendMessageChatParamPtrs contains pointers to parameters of the StorageInterface.SendMessageChat
type StorageInterfaceMockSendMessageChatParamPtrs struct {
	ctx     *context.Context
	message *models.Message
}

// StorageInterfaceMockSendMessageChatResults contains results of the StorageInterface.SendMessageChat
type StorageInterfaceMockSendMessageChatResults struct {
	err error
}

// StorageInterfaceMockSendMessageChatOrigins contains origins of expectations of the StorageInterface.SendMessageChat
type StorageInterfaceMockSendMessageChatExpectationOrigins struct {
	origin        string
	originCtx     string
	originMessage string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Optional() *mStorageInterfaceMockSendMessageChat {
	mmSendMessageChat.optional = true
	return mmSendMessageChat
}

// Expect sets up expected params for StorageInterface.SendMessageChat
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Expect(ctx context.Context, message models.Message) *mStorageInterfaceMockSendMessageChat {
	if mmSendMessageChat.mock.funcSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Set")
	}

	if mmSendMessageChat.defaultExpectation == nil {
		mmSendMessageChat.defaultExpectation = &StorageInterfaceMockSendMessageChatExpectation{}
	}

	if mmSendMessageChat.defaultExpectation.paramPtrs != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by ExpectParams functions")
	}

	mmSendMessageChat.defaultExpectation.params = &StorageInterfaceMockSendMessageChatParams{ctx, message}
	mmSendMessageChat.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendMessageChat.expectations {
		if minimock.Equal(e.params, mmSendMessageChat.defaultExpectation.params) {
			mmSendMessageChat.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessageChat.defaultExpectation.params)
		}
	}

	return mmSendMessageChat
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.SendMessageChat
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockSendMessageChat {
	if mmSendMessageChat.mock.funcSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Set")
	}

	if mmSendMessageChat.defaultExpectation == nil {
		mmSendMessageChat.defaultExpectation = &StorageInterfaceMockSendMessageChatExpectation{}
	}

	if mmSendMessageChat.defaultExpectation.params != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Expect")
	}

	if mmSendMessageChat.defaultExpectation.paramPtrs == nil {
		mmSendMessageChat.defaultExpectation.paramPtrs = &StorageInterfaceMockSendMessageChatParamPtrs{}
	}
	mmSendMessageChat.defaultExpectation.paramPtrs.ctx = &ctx
	mmSendMessageChat.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSendMessageChat
}

// ExpectMessageParam2 sets up expected param message for StorageInterface.SendMessageChat
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) ExpectMessageParam2(message models.Message) *mStorageInterfaceMockSendMessageChat {
	if mmSendMessageChat.mock.funcSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Set")
	}

	if mmSendMessageChat.defaultExpectation == nil {
		mmSendMessageChat.defaultExpectation = &StorageInterfaceMockSendMessageChatExpectation{}
	}

	if mmSendMessageChat.defaultExpectation.params != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Expect")
	}

	if mmSendMessageChat.defaultExpectation.paramPtrs == nil {
		mmSendMessageChat.defaultExpectation.paramPtrs = &StorageInterfaceMockSendMessageChatParamPtrs{}
	}
	mmSendMessageChat.defaultExpectation.paramPtrs.message = &message
	mmSendMessageChat.defaultExpectation.expectationOrigins.originMessage = minimock.CallerInfo(1)

	return mmSendMessageChat
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.SendMessageChat
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Inspect(f func(ctx context.Context, message models.Message)) *mStorageInterfaceMockSendMessageChat {
	if mmSendMessageChat.mock.inspectFuncSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.SendMessageChat")
	}

	mmSendMessageChat.mock.inspectFuncSendMessageChat = f

	return mmSendMessageChat
}

// Return sets up results that will be returned by StorageInterface.SendMessageChat
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Return(err error) *StorageInterfaceMock {
	if mmSendMessageChat.mock.funcSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Set")
	}

	if mmSendMessageChat.defaultExpectation == nil {
		mmSendMessageChat.defaultExpectation = &StorageInterfaceMockSendMessageChatExpectation{mock: mmSendMessageChat.mock}
	}
	mmSendMessageChat.defaultExpectation.results = &StorageInterfaceMockSendMessageChatResults{err}
	mmSendMessageChat.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendMessageChat.mock
}

// Set uses given function f to mock the StorageInterface.SendMessageChat method
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Set(f func(ctx context.Context, message models.Message) (err error)) *StorageInterfaceMock {
	if mmSendMessageChat.defaultExpectation != nil {
		mmSendMessageChat.mock.t.Fatalf("Default expectation is already set for the StorageInterface.SendMessageChat method")
	}

	if len(mmSendMessageChat.expectations) > 0 {
		mmSendMessageChat.mock.t.Fatalf("Some expectations are already set for the StorageInterface.SendMessageChat method")
	}

	mmSendMessageChat.mock.funcSendMessageChat = f
	mmSendMessageChat.mock.funcSendMessageChatOrigin = minimock.CallerInfo(1)
	return mmSendMessageChat.mock
}

// When sets expectation for the StorageInterface.SendMessageChat which will trigger the result defined by the following
// Then helper
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) When(ctx context.Context, message models.Message) *StorageInterfaceMockSendMessageChatExpectation {
	if mmSendMessageChat.mock.funcSendMessageChat != nil {
		mmSendMessageChat.mock.t.Fatalf("StorageInterfaceMock.SendMessageChat mock is already set by Set")
	}

	expectation := &StorageInterfaceMockSendMessageChatExpectation{
		mock:               mmSendMessageChat.mock,
		params:             &StorageInterfaceMockSendMessageChatParams{ctx, message},
		expectationOrigins: StorageInterfaceMockSendMessageChatExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendMessageChat.expectations = append(mmSendMessageChat.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.SendMessageChat return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockSendMessageChatExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockSendMessageChatResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.SendMessageChat should be invoked
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Times(n uint64) *mStorageInterfaceMockSendMessageChat {
	if n == 0 {
		mmSendMessageChat.mock.t.Fatalf("Times of StorageInterfaceMock.SendMessageChat mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendMessageChat.expectedInvocations, n)
	mmSendMessageChat.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendMessageChat
}

func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) invocationsDone() bool {
	if len(mmSendMessageChat.expectations) == 0 && mmSendMessageChat.defaultExpectation == nil && mmSendMessageChat.mock.funcSendMessageChat == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendMessageChat.mock.afterSendMessageChatCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendMessageChat.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendMessageChat implements mm_repointerface.StorageInterface
func (mmSendMessageChat *StorageInterfaceMock) SendMessageChat(ctx context.Context, message models.Message) (err error) {
	mm_atomic.AddUint64(&mmSendMessageChat.beforeSendMessageChatCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessageChat.afterSendMessageChatCounter, 1)

	mmSendMessageChat.t.Helper()

	if mmSendMessageChat.inspectFuncSendMessageChat != nil {
		mmSendMessageChat.inspectFuncSendMessageChat(ctx, message)
	}

	mm_params := StorageInterfaceMockSendMessageChatParams{ctx, message}

	// Record call args
	mmSendMessageChat.SendMessageChatMock.mutex.Lock()
	mmSendMessageChat.SendMessageChatMock.callArgs = append(mmSendMessageChat.SendMessageChatMock.callArgs, &mm_params)
	mmSendMessageChat.SendMessageChatMock.mutex.Unlock()

	for _, e := range mmSendMessageChat.SendMessageChatMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessageChat.SendMessageChatMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessageChat.SendMessageChatMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessageChat.SendMessageChatMock.defaultExpectation.params
		mm_want_ptrs := mmSendMessageChat.SendMessageChatMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockSendMessageChatParams{ctx, message}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSendMessageChat.t.Errorf("StorageInterfaceMock.SendMessageChat got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessageChat.SendMessageChatMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.message != nil && !minimock.Equal(*mm_want_ptrs.message, mm_got.message) {
				mmSendMessageChat.t.Errorf("StorageInterfaceMock.SendMessageChat got unexpected parameter message, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendMessageChat.SendMessageChatMock.defaultExpectation.expectationOrigins.originMessage, *mm_want_ptrs.message, mm_got.message, minimock.Diff(*mm_want_ptrs.message, mm_got.message))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessageChat.t.Errorf("StorageInterfaceMock.SendMessageChat got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendMessageChat.SendMessageChatMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessageChat.SendMessageChatMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessageChat.t.Fatal("No results are set for the StorageInterfaceMock.SendMessageChat")
		}
		return (*mm_results).err
	}
	if mmSendMessageChat.funcSendMessageChat != nil {
		return mmSendMessageChat.funcSendMessageChat(ctx, message)
	}
	mmSendMessageChat.t.Fatalf("Unexpected call to StorageInterfaceMock.SendMessageChat. %v %v", ctx, message)
	return
}

// SendMessageChatAfterCounter returns a count of finished StorageInterfaceMock.SendMessageChat invocations
func (mmSendMessageChat *StorageInterfaceMock) SendMessageChatAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessageChat.afterSendMessageChatCounter)
}

// SendMessageChatBeforeCounter returns a count of StorageInterfaceMock.SendMessageChat invocations
func (mmSendMessageChat *StorageInterfaceMock) SendMessageChatBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessageChat.beforeSendMessageChatCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.SendMessageChat.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessageChat *mStorageInterfaceMockSendMessageChat) Calls() []*StorageInterfaceMockSendMessageChatParams {
	mmSendMessageChat.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockSendMessageChatParams, len(mmSendMessageChat.callArgs))
	copy(argCopy, mmSendMessageChat.callArgs)

	mmSendMessageChat.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageChatDone returns true if the count of the SendMessageChat invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockSendMessageChatDone() bool {
	if m.SendMessageChatMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendMessageChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendMessageChatMock.invocationsDone()
}

// MinimockSendMessageChatInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockSendMessageChatInspect() {
	for _, e := range m.SendMessageChatMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.SendMessageChat at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendMessageChatCounter := mm_atomic.LoadUint64(&m.afterSendMessageChatCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageChatMock.defaultExpectation != nil && afterSendMessageChatCounter < 1 {
		if m.SendMessageChatMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.SendMessageChat at\n%s", m.SendMessageChatMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.SendMessageChat at\n%s with params: %#v", m.SendMessageChatMock.defaultExpectation.expectationOrigins.origin, *m.SendMessageChatMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessageChat != nil && afterSendMessageChatCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.SendMessageChat at\n%s", m.funcSendMessageChatOrigin)
	}

	if !m.SendMessageChatMock.invocationsDone() && afterSendMessageChatCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.SendMessageChat at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendMessageChatMock.expectedInvocations), m.SendMessageChatMock.expectedInvocationsOrigin, afterSendMessageChatCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateChatInspect()

			m.MinimockDeleteChatInspect()

			m.MinimockLogInspect()

			m.MinimockSendMessageChatInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateChatDone() &&
		m.MinimockDeleteChatDone() &&
		m.MinimockLogDone() &&
		m.MinimockSendMessageChatDone()
}
